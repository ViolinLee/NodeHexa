动作组扩展开发允许您创建自定义的运动模式。本章详细介绍如何从零开始创建一个新的动作组，包括轨迹生成、验证和集成到固件的完整流程。

#  10.1 轨迹生成流程

**整体流程：**

```
1. 编写路径生成脚本（Python）
   ↓
2. 运行pathTool生成轨迹表
   ↓
3. 验证轨迹点（自动）
   ↓
4. 生成C++代码（movement_table.h）
   ↓
5. 集成到固件（movements.cpp）
   ↓
6. 添加运动模式枚举（movement.h）
   ↓
7. 编译测试
```

**准备工作：**

1. **环境要求：**
   - Python 3.x
   - NumPy库：`pip install numpy`
   - 熟悉Python基础语法

2. **目录结构：**
   ```
   reference/pathTool/src/
   ├── main.py           # 主程序（无需修改）
   ├── config.py         # 配置参数（一般无需修改）
   ├── kinematics.py     # 逆运动学（无需修改）
   ├── path/             # 路径脚本目录
   │   ├── forward.py    # 示例脚本
   │   ├── lib.py        # 工具函数库
   │   └── your_new.py   # 您的新脚本
   └── output/
       └── movement_table.h  # 生成的轨迹表
   ```

**关键概念：**

- **轨迹点（Path Point）：** 单个时间点六条腿的足端位置
- **轨迹（Path）：** 一条腿的完整运动轨迹（一系列轨迹点）
- **动作组（Movement Table）：** 所有轨迹点和步态入口的集合
- **步态入口（Entry）：** 步态周期的起始点索引

#  10.2 编写路径生成脚本

##  10.2.1 脚本基本结构

每个路径生成脚本必须包含一个 `path_generator()` 函数，返回4个值：

```python
def path_generator():
    # ... 轨迹生成代码 ...
    
    return data, mode, dur, entries
```

**返回值说明：**

1. **data：** 轨迹数据
   - `shift`模式：`list[list[list[float]]]` - `[6条腿][N个点][x,y,z]`
   - `matrix`模式：`list[np.matrix]` - `[N个变换矩阵]`

2. **mode：** 生成模式字符串
   - `"shift"`：偏移模式，每条腿有独立的轨迹
   - `"matrix"`：矩阵模式，使用变换矩阵作用于基准位置

3. **dur：** 每步持续时间（毫秒），例如 `20` 表示每20ms一个轨迹点

4. **entries：** 步态入口索引元组，例如 `(0, 10)` 表示两个步态组

##  10.2.2 Shift模式（偏移模式）

**适用场景：** 每条腿需要独立轨迹的运动，如前进、后退、平移等。

**数据格式：**
```python
[
    [腿0的轨迹点列表],  # [(x0,y0,z0), (x1,y1,z1), ...]
    [腿1的轨迹点列表],
    [腿2的轨迹点列表],
    [腿3的轨迹点列表],
    [腿4的轨迹点列表],
    [腿5的轨迹点列表],
]
```

**示例：前进动作（forward.py）**

```python
from collections import deque
from lib import semicircle_generator

g_steps = 20      # 轨迹点数量（必须是4的倍数）
g_radius = 25     # 轨迹半径（mm）

def path_generator():
    assert (g_steps % 4) == 0  # 确保是4的倍数
    halfsteps = int(g_steps/2)
    
    # 1. 生成标准半圆形轨迹
    path = semicircle_generator(g_radius, g_steps)
    
    # 2. 创建镜像轨迹（偏移半个周期）
    mir_path = deque(path)
    mir_path.rotate(halfsteps)
    
    # 3. 为6条腿分配轨迹（交替使用path和mir_path）
    return [
        path,      # 腿0
        mir_path,  # 腿1
        path,      # 腿2
        mir_path,  # 腿3
        path,      # 腿4
        mir_path,  # 腿5
    ], "shift", 20, (0, halfsteps)
```

**关键点：**

- **三足步态：** 腿0、2、4使用`path`，腿1、3、5使用`mir_path`（或相反）
- **步态入口：** `(0, halfsteps)` 表示从索引0和10开始交替
- **轨迹旋转：** 使用`deque.rotate()`实现相位差

**示例：左转动作（turnleft.py）**

```python
from collections import deque
from lib import semicircle_generator
from lib import path_rotate_z

g_steps = 20
g_radius = 25

def path_generator():
    assert (g_steps % 4) == 0
    halfsteps = int(g_steps/2)
    
    path = semicircle_generator(g_radius, g_steps)
    mir_path = deque(path)
    mir_path.rotate(halfsteps)
    
    # 为每条腿应用不同的旋转角度
    return [
        path_rotate_z(path, 45),    # 腿0：旋转45度
        path_rotate_z(mir_path, 0), # 腿1：不旋转
        path_rotate_z(path, 315),   # 腿2：旋转315度
        path_rotate_z(mir_path, 225), # 腿3：旋转225度
        path_rotate_z(path, 180),   # 腿4：旋转180度
        path_rotate_z(mir_path, 135), # 腿5：旋转135度
    ], "shift", 20, (0, halfsteps)
```

**旋转角度说明：**

每条腿的旋转角度基于其安装角度（见`config.py`中的`defaultAngle`）。旋转轨迹使其产生转向效果。

##  10.2.3 Matrix模式（矩阵模式）

**适用场景：** 需要整体变换的运动，如旋转、倾斜等。

**数据格式：**
```python
[
    变换矩阵1,  # 4x4齐次变换矩阵
    变换矩阵2,
    ...
]
```

**变换矩阵格式：**
```python
np.matrix([
    [r00, r01, r02, tx],  # 旋转+平移
    [r10, r11, r12, ty],
    [r20, r21, r22, tz],
    [0,   0,   0,   1 ],
])
```

**示例：X轴旋转（rotatex.py）**

```python
from collections import deque
import math
from lib import get_rotate_x_matrix as get_matrix

g_steps = 20
swing_angle = 15      # 摆动角度（度）
y_radius = 15         # Y方向偏移半径（mm）

def path_generator():
    assert (g_steps % 4) == 0
    quarter = int(g_steps/4)
    
    result = []
    step_angle = swing_angle / quarter
    step_offset = y_radius / quarter
    
    # 第一段：抬起并旋转
    for i in range(quarter):
        m = get_matrix(swing_angle - i*step_angle)  # 旋转矩阵
        m[1,3] = -i * step_offset                   # Y方向偏移
        result.append(m)
    
    # 第二段：下降并旋转
    for i in range(quarter):
        m = get_matrix(-i*step_angle)
        m[1,3] = -y_radius + i * step_offset
        result.append(m)
    
    # 第三段：反向抬起
    for i in range(quarter):
        m = get_matrix(i*step_angle-swing_angle)
        m[1,3] = i * step_offset
        result.append(m)
    
    # 第四段：回到起始位置
    for i in range(quarter):
        m = get_matrix(i*step_angle)
        m[1,3] = y_radius-i * step_offset
        result.append(m)
    
    return result, "matrix", 50, (0, quarter*2)
```

**矩阵生成工具函数：**

- `get_rotate_x_matrix(angle)`：绕X轴旋转矩阵
- `get_rotate_y_matrix(angle)`：绕Y轴旋转矩阵
- `get_rotate_z_matrix(angle)`：绕Z轴旋转矩阵

**矩阵应用：**

在生成C++代码时，矩阵会作用于每条腿的基准位置（`defaultPosition`）：

```cpp
// 生成的C++代码示例
pt = P1X * m00 + P1Y * m01 + P1Z * m02 + tx;
pt = P1X * m10 + P1Y * m11 + P1Z * m12 + ty;
pt = P1X * m20 + P1Y * m21 + P1Z * m22 + tz;
```

##  10.2.4 工具函数库（lib.py）

**常用函数：**

1. **轨迹生成：**
   - `semicircle_generator(radius, steps, reverse=False)`：生成半圆形轨迹
   - `semicircle2_generator(steps, y_radius, z_radius, x_radius, reverse=False)`：生成三维半圆形轨迹

2. **轨迹变换：**
   - `path_rotate_x(path, angle)`：绕X轴旋转轨迹
   - `path_rotate_y(path, angle)`：绕Y轴旋转轨迹
   - `path_rotate_z(path, angle)`：绕Z轴旋转轨迹

3. **矩阵生成：**
   - `get_rotate_x_matrix(angle)`：X轴旋转矩阵
   - `get_rotate_y_matrix(angle)`：Y轴旋转矩阵
   - `get_rotate_z_matrix(angle)`：Z轴旋转矩阵
   - `matrix_mul(m, pt)`：矩阵乘法

**使用建议：**

- 优先使用工具函数，减少重复代码
- 理解每个函数的参数和返回值
- 参考现有脚本学习最佳实践

##  10.2.5 参数调优

**轨迹点数量（steps）：**
- 默认：20点
- 更多点：运动更平滑，但占用更多内存
- 更少点：内存占用少，但可能不够平滑
- **必须**是4的倍数（用于步态分组）

**轨迹半径（radius）：**
- 默认：25mm
- 增大：步幅更大，速度更快
- 减小：步幅更小，更稳定
- 注意：不要超过运动学限制

**步进时间（dur）：**
- 默认：20ms（50Hz）
- 与舵机响应速度匹配
- 更小：运动更快，但可能不稳定
- 更大：运动更慢，更稳定

**步态入口（entries）：**
- 三足步态：`(0, halfsteps)`，例如`(0, 10)`
- 四足步态：`(0, quarter, half, quarter*3)`，例如`(0, 5, 10, 15)`
- 根据步态需求调整

#  10.3 轨迹验证

pathTool会自动验证所有轨迹点是否在安全范围内。

**验证流程：**

1. **读取轨迹数据**
2. **对每个轨迹点：**
   - 计算世界坐标系下的足端位置
   - 执行逆运动学计算关节角度
   - 检查角度是否在限制范围内
3. **报告错误：** 如果发现超出范围的点，显示错误并退出

**角度限制（config.py）：**
```python
angleLimitation = (
    (-45, 45),   # 关节1：-45° ~ 45°
    (-45, 75),   # 关节2：-45° ~ 75°
    (-60, 60),   # 关节3：-60° ~ 60°
)
```

**验证失败处理：**

如果验证失败，程序会输出：
```
Verifying forward...
10, 2 failed: [(0, 50.5), (1, 80.2)]  # 索引10，腿2，角度超出限制
There were errors, exit...
```

**解决方案：**

1. **减小轨迹半径：** 降低运动幅度
2. **调整轨迹形状：** 避免极端位置
3. **检查坐标系转换：** 确保坐标正确
4. **修改运动学参数：** 如果硬件允许

**验证通过：**

如果所有轨迹点都通过验证，程序会继续生成C++代码。

#  10.4 集成到固件

##  10.4.1 生成轨迹表

**步骤1：运行pathTool**

```bash
cd reference/pathTool/src
python main.py
```

**步骤2：检查输出**

生成的`movement_table.h`会包含：
```cpp
const Locations your_new_paths[] {
    {{P1X+(0.00), P1Y+(0.00), P1Z+(25.00)}, ...},
    // ... 更多轨迹点
};
const int your_new_entries[] { 0, 10 };
const MovementTable your_new_table {your_new_paths, 20, 20, your_new_entries, 2};

const MovementTable& yourNewTable() {
    return your_new_table;
}
```

##  10.4.2 添加到movement.h

**步骤1：添加运动模式枚举**

在`firmware/src/movement.h`中添加：

```cpp
enum MovementMode {
    MOVEMENT_STANDBY = 0,
    // ... 现有模式 ...
    MOVEMENT_YOUR_NEW,      // 添加新模式
    MOVEMENT_TOTAL,
};
```

**注意：** 必须放在`MOVEMENT_TOTAL`之前。

##  10.4.3 添加到movements.cpp

**步骤1：添加声明**

在`movements.cpp`顶部添加：

```cpp
extern const MovementTable& yourNewTable();
```

**步骤2：添加到映射表**

在`kTable`数组中添加：

```cpp
const MovementTable kTable[MOVEMENT_TOTAL] {
    standbyTable(),
    forwardTable(),
    // ... 现有动作组 ...
    yourNewTable(),      // 添加新动作组
};
```

**步骤3：确保顺序匹配**

`kTable`数组的顺序必须与`MovementMode`枚举顺序一致。

##  10.4.4 更新Web控制界面

**步骤1：更新HTML**

在`include/controller_index.h`中，添加新的控制按钮：

```html
<button onclick="sendCommand(YOUR_NEW_MODE)">新动作</button>
```

**步骤2：更新JavaScript**

添加对应的模式编号：

```javascript
const YOUR_NEW_MODE = 13;  // 与枚举值对应
```

##  10.4.5 编译和测试

**步骤1：编译固件**

```bash
cd firmware
pio run
```

**步骤2：上传固件**

```bash
pio run --target upload
```

**步骤3：测试**

1. 连接WiFi热点
2. 打开Web控制界面
3. 测试新动作组
4. 观察机器人运动是否正常

**调试技巧：**

- 使用串口监视器观察日志
- 检查运动模式是否正确切换
- 验证轨迹点是否平滑
- 检查是否有异常停止

#  10.5 动作组示例

##  10.5.1 示例1：简单前进动作

**需求：** 创建一个简单的直线前进动作

**脚本代码（simple_forward.py）：**

```python
from collections import deque

g_steps = 16  # 简化为16点
g_step_size = 10  # 每步前进10mm

def path_generator():
    assert (g_steps % 4) == 0
    halfsteps = int(g_steps/2)
    
    # 生成简单的前后移动轨迹
    path = []
    for i in range(halfsteps):
        # 前半段：抬起并后退
        y = -g_step_size + i * (2 * g_step_size / halfsteps)
        z = 15 if i < halfsteps/2 else 15 - (i - halfsteps/2) * (15 / (halfsteps/2))
        path.append((0, y, z))
    
    for i in range(halfsteps):
        # 后半段：前进并放下
        y = g_step_size - i * (2 * g_step_size / halfsteps)
        z = 0 if i < halfsteps/2 else (i - halfsteps/2) * (15 / (halfsteps/2))
        path.append((0, y, z))
    
    path = deque(path)
    path.rotate(int(g_steps/4))
    
    mir_path = deque(path)
    mir_path.rotate(halfsteps)
    
    return [path, mir_path, path, mir_path, path, mir_path], "shift", 25, (0, halfsteps)
```

**特点：**
- 使用简单的直线轨迹
- 步幅较小（10mm）
- 适合精细控制

##  10.5.2 示例2：跳跃动作

**需求：** 创建一个所有腿同时抬起的跳跃动作

**脚本代码（jump.py）：**

```python
import math

g_steps = 20
g_jump_height = 30  # 跳跃高度（mm）

def path_generator():
    assert (g_steps % 4) == 0
    halfsteps = int(g_steps/2)
    
    # 生成跳跃轨迹（所有腿同步）
    path = []
    for i in range(g_steps):
        # 前半段：抬起
        if i < halfsteps:
            z = (g_jump_height * math.sin(math.pi * i / halfsteps))
        # 后半段：下降
        else:
            z = (g_jump_height * math.sin(math.pi * (g_steps - i) / halfsteps))
        path.append((0, 0, z))
    
    # 所有6条腿使用相同轨迹
    return [path] * 6, "shift", 30, (0,)
```

**特点：**
- 所有腿同步运动
- 单一步态入口
- 适合展示动作

##  10.5.3 示例3：自定义轨迹

**需求：** 创建一个8字形轨迹

**脚本代码（figure8.py）：**

```python
import math

g_steps = 24
g_radius = 20

def path_generator():
    assert (g_steps % 4) == 0
    
    # 生成8字形轨迹
    path = []
    for i in range(g_steps):
        t = 2 * math.pi * i / g_steps
        # 8字形参数方程
        x = g_radius * math.sin(t)
        y = g_radius * math.sin(t) * math.cos(t)
        z = 10 * math.sin(2 * t)  # 高度变化
        path.append((x, y, z))
    
    from collections import deque
    mir_path = deque(path)
    mir_path.rotate(int(g_steps/2))
    
    return [path, mir_path, path, mir_path, path, mir_path], "shift", 25, (0, int(g_steps/2))
```

**特点：**
- 使用参数方程
- 复杂的轨迹形状
- 适合特殊动作展示

##  10.5.4 开发建议

**最佳实践：**

1. **从简单开始：** 先实现基本功能，再优化
2. **参考现有脚本：** 学习成熟的实现方式
3. **小步迭代：** 每次修改后测试验证
4. **参数化配置：** 使用全局变量便于调整
5. **文档注释：** 添加注释说明设计思路

**常见问题：**

1. **验证失败：** 检查轨迹半径是否过大
2. **运动不平滑：** 增加轨迹点数量
3. **步态不协调：** 检查步态入口设置
4. **编译错误：** 确保枚举和映射表顺序一致

**扩展思路：**

- **复杂步态：** 尝试四足步态、波浪步态等
- **环境适应：** 添加高度检测、地形适应
- **动态调整：** 根据速度动态调整轨迹
- **组合动作：** 将多个简单动作组合

通过以上步骤，您就可以创建自定义的动作组了。记住：实践是最好的老师，多尝试不同的参数和轨迹形状，找到最适合您需求的动作组。

---
