本章节详细介绍NodeHexa六足机器人的日常使用方法，包括Web控制界面操作、舵机校准、串口控制和电池监测等功能。

#  8.1 Web控制界面

##  8.1.1 连接WiFi

**步骤1：启动机器人**

1. 确保机器人已上电（电池或外接电源）
2. 等待ESP32启动（约5-10秒）
3. 观察串口输出或LED指示灯，确认启动成功

**步骤2：查找WiFi热点**

ESP32启动后会自动创建WiFi热点：
- **SSID：** `NodeHexa`
- **密码：** `roboticscv666`
- **IP地址：** `192.168.4.1`（ESP32默认AP IP）

**步骤3：连接WiFi**

使用手机或电脑连接WiFi热点：

**手机连接：**
1. 打开WiFi设置
2. 搜索并选择`NodeHexa`网络
3. 输入密码：`roboticscv666`
4. 连接成功后，设备会获得`192.168.4.x`的IP地址

**电脑连接：**
1. 点击系统托盘中的WiFi图标
2. 选择`NodeHexa`网络
3. 输入密码：`roboticscv666`
4. 连接成功

**注意事项：**
- 连接WiFi热点后，设备将无法访问互联网
- WiFi覆盖范围约10-30米（视环境而定）
- 最多支持4个客户端同时连接
- 如果无法连接，检查WiFi密码是否正确，或重启机器人

##  8.1.2 访问控制页面

**步骤1：打开浏览器**

使用支持WebSocket的现代浏览器：
- Chrome（推荐）
- Firefox
- Edge
- Safari

**步骤2：访问控制页面**

在浏览器地址栏输入：
```
http://192.168.4.1
```

**步骤3：确认页面加载**

成功加载后，您应该能看到：
- 机器人控制界面
- 运动控制按钮（前进、后退、转向等）
- 速度控制滑块
- 校准按钮

**页面功能：**

**主控制区域：**
- 运动模式按钮：前进、后退、左转、右转、左移、右移等
- 姿态控制：X/Y/Z轴旋转、扭转动作
- 速度控制：速度滑块或速度等级按钮
- 待机按钮：停止所有运动

**导航菜单：**
- 主控制页面：`/`
- 校准页面：`/calibration`

**WebSocket连接：**

页面会自动建立WebSocket连接（`ws://192.168.4.1/cmd`），用于实时控制。连接成功后，控制按钮会变为可用状态。

**常见问题：**
- **页面无法加载：** 确认WiFi已连接，检查IP地址是否正确
- **控制无响应：** 检查WebSocket连接状态，刷新页面重试
- **按钮灰色：** WebSocket未连接，等待连接建立或刷新页面

##  8.1.3 运动控制操作

**基本运动控制：**

**1. 前进/后退：**
- 点击"前进"按钮，机器人开始前进
- 点击"后退"按钮，机器人开始后退
- 点击"待机"按钮停止运动

**2. 转向控制：**
- 点击"左转"按钮，机器人逆时针旋转
- 点击"右转"按钮，机器人顺时针旋转
- 点击"待机"按钮停止旋转

**3. 侧向移动：**
- 点击"左移"按钮，机器人向左平移
- 点击"右移"按钮，机器人向右平移

**4. 姿态控制：**
- **X轴旋转：** 机器人绕X轴旋转
- **Y轴旋转：** 机器人绕Y轴旋转
- **Z轴旋转：** 机器人绕Z轴旋转
- **扭转：** 机器人执行扭转动作

**5. 特殊动作：**
- **攀爬：** 攀爬动作模式
- **快速前进：** 快速前进模式

**速度控制：**

**方法1：速度滑块**
- 拖动速度滑块调整运动速度
- 范围：0.25x - 1.0x
- 实时生效

**方法2：速度等级按钮**
- 点击速度等级按钮（极慢、慢速、中速、快速）
- 对应速度倍数：
  - 极慢：0.25x
  - 慢速：0.33x
  - 中速：0.5x（默认）
  - 快速：1.0x

**操作提示：**
- **安全第一：** 在开阔、安全的环境中进行测试
- **逐步测试：** 先使用慢速模式测试，确认正常后再提高速度
- **观察状态：** 注意观察机器人运动是否流畅，是否有异常
- **及时停止：** 发现异常立即点击"待机"按钮停止运动

**模式切换：**

- 点击不同的运动模式按钮会立即切换运动模式
- 系统会自动进行平滑过渡（约150ms）
- 可以随时点击"待机"按钮停止运动

#  8.2 舵机校准

##  8.2.1 进入校准模式

**为什么要校准：**

由于制造公差和机械装配误差，每个舵机的零位可能略有不同。校准功能允许您微调每个舵机的角度偏移，确保机器人运动准确。

**进入校准模式：**

**方法1：通过Web界面**

1. 访问主控制页面：`http://192.168.4.1`
2. 点击"校准"按钮或导航到校准页面：`http://192.168.4.1/calibration`
3. 点击"开始校准"按钮
4. 系统会进入校准模式，清除所有现有偏移

**方法2：直接访问校准页面**

1. 直接访问：`http://192.168.4.1/calibration`
2. 点击"开始校准"按钮

**校准模式特点：**

- 进入校准模式后，所有舵机偏移量会被清除
- 机器人会执行测试动作，展示当前角度
- 可以通过界面实时调整每个舵机的角度
- 调整会立即生效，可以看到实时效果

**退出校准模式：**

校准完成后，点击"保存并退出"按钮：
- 校准数据会保存到Flash存储（`/calibration.json`）
- 系统会退出校准模式，返回正常运动模式
- 页面会自动跳转到主控制页面

##  8.2.2 校准操作流程

**校准界面说明：**

校准页面显示18个舵机的控制界面（6条腿 × 3个关节）：

**界面布局：**
- 每条腿显示3个关节的控制
- 每个关节有"增加"和"减少"按钮
- 显示当前偏移量数值
- 可以输入数值直接设置偏移量

**腿编号说明：**

```
     leg5   leg0
     /        \
    /          \
 leg4          leg1
    \          /
     \        /
    leg3    leg2
```

**关节编号：**
- **关节0：** 根部关节（水平旋转）
- **关节1：** 中间关节（垂直方向）
- **关节2：** 末端关节（足端倾斜）

**校准步骤：**

**步骤1：观察待机姿态**

进入校准模式后，机器人会显示待机姿态。观察每条腿的姿态是否对称、是否正确。

**步骤2：逐个调整舵机**

1. 选择需要调整的腿和关节
2. 点击"增加"或"减少"按钮微调角度
3. 观察机器人姿态变化
4. 重复调整直到姿态正确

**步骤3：对称性检查**

调整完一侧的腿后，检查对称侧（如leg0和leg5）是否对称，确保左右对称。

**步骤4：测试运动**

- 可以切换到运动模式测试（需要先保存）
- 或暂时退出校准模式测试运动效果
- 根据测试结果进一步调整

**校准技巧：**

1. **小步调整：** 每次调整幅度不要太大，逐步微调
2. **对称调整：** 优先调整对称的腿，保持对称性
3. **基准腿：** 先调整一条腿作为基准，其他腿参考基准腿调整
4. **实时观察：** 调整后立即观察效果，避免过度调整
5. **多次测试：** 调整后测试不同运动模式，确保在各种运动下都正常

**偏移量范围：**

- 偏移量单位为PWM脉宽微秒（μs）
- 范围：约-1000到+1000（对应约±90°）
- 实际有效范围取决于舵机规格

**注意事项：**

- 校准过程中不要断开电源
- 校准数据会保存在Flash中，断电不丢失
- 如果校准错误，可以重新进入校准模式清除偏移
- 建议在校准前备份原始校准数据（如果需要）

##  8.2.3 保存校准数据

**自动保存：**

校准数据会在以下情况自动保存：
- 点击"保存并退出"按钮时
- 校准数据会写入Flash存储（`/calibration.json`）

**保存格式：**

校准数据以JSON格式保存在SPIFFS文件系统中：

```json
{
  "leg0": [0, 0, 0],
  "leg1": [0, 0, 0],
  "leg2": [0, 0, 0],
  "leg3": [0, 0, 0],
  "leg4": [0, 0, 0],
  "leg5": [0, 0, 0]
}
```

每个数组包含3个偏移量值，对应3个关节。

**加载校准数据：**

系统启动时会自动加载校准数据：
- 从`/calibration.json`文件读取
- 如果文件不存在，使用默认值（全0）
- 加载后应用到所有舵机

**重置校准数据：**

如果需要重置所有校准数据：

1. 重新进入校准模式
2. 点击"开始校准"按钮（会清除所有偏移）
3. 重新调整或直接保存（全部为0）

**备份和恢复：**

**备份校准数据：**
- 可以通过串口监视器查看校准数据
- 或通过SPIFFS文件系统访问文件

**恢复校准数据：**
- 修改`/calibration.json`文件
- 或重新进入校准模式调整

**验证校准：**

保存校准数据后：
1. 退出校准模式
2. 测试各种运动模式
3. 观察运动是否流畅、对称
4. 如有问题，重新进入校准模式调整

#  8.3 串口控制

##  8.3.1 串口连接

**硬件连接：**

**UART2串口配置：**
- **RX引脚：** GPIO16
- **TX引脚：** GPIO17
- **波特率：** 115200
- **数据位：** 8
- **停止位：** 1
- **校验位：** 无

**连接方式：**

1. **USB转串口模块：**
   - 使用USB转TTL串口模块
   - 连接GPIO16（RX）和GPIO17（TX）
   - 注意：RX接TX，TX接RX（交叉连接）
   - GND需要共地

2. **其他MCU连接：**
   - 从其他微控制器通过UART2发送控制指令
   - 确保波特率匹配（115200）
   - 确保电平匹配（3.3V）

**串口工具：**

**Windows系统：**
- PlatformIO串口监视器（推荐）
- PuTTY
- 串口助手
- Arduino IDE串口监视器

**Linux系统：**
- PlatformIO串口监视器
- Screen：`screen /dev/ttyUSB0 115200`
- Minicom：`minicom -D /dev/ttyUSB0 -b 115200`

**macOS系统：**
- PlatformIO串口监视器
- Screen：`screen /dev/cu.usbserial-* 115200`

**验证连接：**

连接后，串口监视器应该能看到：
- 启动信息
- 系统日志
- 指令响应

##  8.3.2 命令格式

**数据帧格式：**

串口指令采用帧格式，以`$`开头，以`\n`（换行符）结尾：

```
$<JSON数据>\n
```

**示例：**
```
${"movementMode": 1}\n
```

**JSON格式：**

指令采用JSON格式，与WebSocket格式相同：

**运动模式指令：**
```json
{
  "movementMode": 1
}
```

**速度控制指令：**
```json
{
  "speed": 0.5
}
```

**速度等级指令：**
```json
{
  "speedLevel": 2
}
```

**组合指令：**
```json
{
  "movementMode": 1,
  "speed": 0.5
}
```

**运动模式编号：**

| 模式编号 | 模式名称 | 说明 |
|---------|---------|------|
| 0 | MOVEMENT_STANDBY | 待机 |
| 1 | MOVEMENT_FORWARD | 前进 |
| 2 | MOVEMENT_FORWARDFAST | 快速前进 |
| 3 | MOVEMENT_BACKWARD | 后退 |
| 4 | MOVEMENT_TURNLEFT | 左转 |
| 5 | MOVEMENT_TURNRIGHT | 右转 |
| 6 | MOVEMENT_SHIFTLEFT | 左移 |
| 7 | MOVEMENT_SHIFTRIGHT | 右移 |
| 8 | MOVEMENT_CLIMB | 攀爬 |
| 9 | MOVEMENT_ROTATEX | X轴旋转 |
| 10 | MOVEMENT_ROTATEY | Y轴旋转 |
| 11 | MOVEMENT_ROTATEZ | Z轴旋转 |
| 12 | MOVEMENT_TWIST | 扭转 |

**速度等级：**

| 等级 | 数值 | 倍数 | 说明 |
|------|------|------|------|
| SPEED_SLOWEST | 0 | 0.25 | 极慢 |
| SPEED_SLOW | 1 | 0.33 | 慢速 |
| SPEED_MEDIUM | 2 | 0.5 | 中速（默认） |
| SPEED_FAST | 3 | 1.0 | 快速 |

**响应格式：**

服务器会通过串口发送响应：

**成功响应：**
```json
{
  "status": "success",
  "movementMode": 1,
  "message": "Movement command executed"
}
```

**错误响应：**
```json
{
  "status": "error",
  "message": "Invalid JSON format"
}
```

**使用示例：**

**Python示例：**
```python
import serial
import json
import time

# 打开串口
ser = serial.Serial('/dev/ttyUSB0', 115200, timeout=1)

# 发送前进指令
command = {"movementMode": 1}
ser.write(f"${json.dumps(command)}\n".encode())

# 等待响应
time.sleep(0.1)
response = ser.readline().decode().strip()
print(f"Response: {response}")

# 关闭串口
ser.close()
```

**Arduino示例：**
```cpp
void setup() {
  Serial2.begin(115200);
}

void loop() {
  // 发送前进指令
  Serial2.print("${\"movementMode\":1}\n");
  
  // 等待响应
  delay(100);
  if (Serial2.available()) {
    String response = Serial2.readStringUntil('\n');
    Serial.println(response);
  }
  
  delay(1000);
}
```

**注意事项：**
- 确保帧格式正确（`$`开头，`\n`结尾）
- JSON格式必须正确，否则会返回错误
- 超时时间：1000ms（超过该时间未收到完整帧会清空缓冲区）
- 响应会通过串口发送，注意接收处理

#  8.4 电池监测

**电池监测功能：**

NodeHexa内置电池电压监测功能，实时监控电池电压状态。

**监测原理：**

- **ADC引脚：** GPIO34（仅输入引脚）
- **分压电路：** 100kΩ + 47kΩ（将电池电压降至ADC可测量范围）
- **采样频率：** 每1秒采样一次
- **滤波方式：** 10点移动平均滤波

**低电压保护：**

- **阈值电压：** 6.4V
- **警告方式：** LED指示灯闪烁（GPIO25）
- **闪烁周期：** 300ms

**LED指示灯：**

- **正常状态：** LED常灭
- **低电压状态：** LED闪烁（300ms周期）

**电压计算：**

实际电压计算公式：
```
实际电压 = ADC值 × 3.3 / 4095 × (100 + 47) / 47
        = ADC值 × 3.3 / 4095 × 3.1277
```

**查看电压信息：**

**方法1：串口监视器**

启用调试模式后，串口会输出电压信息：
```
ADC Debug - Raw: 2500, Average: 2537, Voltage: 6.40V, Threshold: 6.40V
```

**方法2：代码调试**

在`main.cpp`中启用`DEBUG_ADC_MONITOR`宏定义：
```cpp
#define DEBUG_ADC_MONITOR  // 取消注释启用调试输出
```

**电池维护建议：**

1. **及时充电：** 低电压警告时及时充电或更换电池
2. **避免过放：** 不要等到完全没电再充电
3. **使用保护板：** 确保使用带有保护板的锂电池
4. **安全第一：** 充电时断开机器人电源
5. **定期检查：** 定期检查电池电压和状态

**注意事项：**

- 低电压警告时建议停止使用并充电
- 电池电压过低可能导致运动不稳定
- 长时间低电压可能损坏电池
- 建议在电压正常时使用机器人

**TODO：** 需要补充电池规格、充电方式、维护周期等详细信息

---
