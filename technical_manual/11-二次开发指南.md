> **⚠️ 重要提醒：** 在进行二次开发前，请务必阅读文档开头的[重要说明](#重要说明)，了解技术支持政策和免责声明。二次开发可能导致硬件损坏，请谨慎操作。

本章节为有经验的开发者提供二次开发的详细指南。如果您是初学者，建议先：
1. 完整阅读本手册的前10章，理解系统原理和代码结构
2. 参考第10章"动作组扩展开发"学习如何添加自定义动作
3. 熟悉代码后再进行更深入的二次开发

#  11.1 开发环境搭建

**环境要求：**

开发环境搭建是二次开发的第一步，请确保以下环境已正确配置：

**必需环境：**

1. **Visual Studio Code + PlatformIO插件**
   - 参考第5章"环境配置"完成安装
   - 确保PlatformIO能够正常编译ESP32项目

2. **Python 3.x（用于轨迹生成工具）**
   - 下载地址：https://www.python.org/
   - 安装NumPy库：`pip install numpy`

3. **Git（推荐）**
   - 用于版本控制
   - 下载地址：https://git-scm.com/

**项目结构：**

熟悉项目目录结构：
```
NodeHexa/
├── firmware/          # 固件源代码
│   ├── src/          # 源代码目录
│   ├── include/      # 头文件目录
│   ├── lib/          # 第三方库
│   └── platformio.ini # 项目配置
├── reference/        # 参考工具（pathTool）
└── TechnicalManual.md # 技术手册
```

**验证环境：**

1. 打开VSCode，打开`firmware`目录
2. 编译项目：`pio run`
3. 确认编译成功，无错误
4. 验证串口连接：`pio device list`

**开发工具配置：**

- **代码格式化：** VSCode支持C++格式化（Ctrl+Shift+P → Format Document）
- **代码补全：** PlatformIO自动提供代码补全
- **调试工具：** PlatformIO支持GDB调试（需要硬件调试器）

#  11.2 代码结构理解

**核心模块：**

**1. 主程序（main.cpp）**
- 系统初始化
- Web服务器和WebSocket服务
- FreeRTOS任务管理
- 主循环逻辑

**2. 六足控制模块（hexapod.h/cpp）**
- `HexapodClass`：顶层控制类
- 管理6条腿实例
- 运动处理接口
- 校准数据管理

**3. 腿部控制模块（leg.h/cpp）**
- `Leg`：单条腿控制类
- 运动学计算（正/逆运动学）
- 坐标系转换

**4. 动作控制模块（movement.h/cpp, movements.cpp）**
- `Movement`：动作执行类
- 动作组切换和插值
- 速度控制

**5. 舵机控制模块（servo.h/cpp）**
- `Servo`：舵机控制类
- 角度设置和校准偏移

**代码组织原则：**

- **命名空间：** 核心代码使用`hexapod`命名空间
- **模块化：** 每个功能模块独立，便于维护
- **配置分离：** 配置参数集中在`config.h`和`PinDefines.h`

**关键数据结构：**

**Point3D：** 三维点坐标
```cpp
struct Point3D {
    float x, y, z;
};
```

**Locations：** 六条腿的足端位置集合
```cpp
struct Locations {
    Point3D legs[6];
    Point3D& get(int index);
};
```

**MovementTable：** 动作组表结构
```cpp
struct MovementTable {
    const Locations* table;
    int length;
    int stepDuration;
    const int* entries;
    int entriesCount;
};
```

#  11.3 自定义运动模式

**添加新运动模式的步骤：**

**步骤1：编写轨迹生成脚本**

参考第10章"动作组扩展开发"，在`reference/pathTool/src/path/`目录下创建新的Python脚本。

**步骤2：生成轨迹表**

运行pathTool生成`movement_table.h`：
```bash
cd reference/pathTool/src
python main.py
```

**步骤3：添加运动模式枚举**

在`firmware/src/movement.h`中添加：
```cpp
enum MovementMode {
    MOVEMENT_STANDBY = 0,
    // ... 现有模式 ...
    MOVEMENT_YOUR_NEW,      // 添加新模式
    MOVEMENT_TOTAL,
};
```

**步骤4：集成到动作表**

在`firmware/src/movements.cpp`中：
1. 添加声明：`extern const MovementTable& yourNewTable();`
2. 添加到`kTable`数组

**步骤5：更新Web界面**

在`include/controller_index.h`中添加控制按钮和JavaScript代码。

**步骤6：编译测试**

```bash
cd firmware
pio run
pio run --target upload
```

**注意事项：**

- 确保枚举顺序与`kTable`数组顺序一致
- 轨迹点必须通过逆运动学验证
- 测试时使用慢速模式，逐步提高速度

#  11.4 添加新功能模块

**添加新功能的通用流程：**

**步骤1：设计功能接口**

确定功能需求，设计接口：
- 输入参数
- 返回值
- 错误处理

**步骤2：实现功能代码**

在适当的模块中实现功能：
- 相关功能放在对应模块
- 新功能可以创建新文件

**步骤3：集成到主程序**

在`main.cpp`中调用新功能：
- 初始化调用
- 主循环调用（如需要）
- 事件处理

**步骤4：添加配置选项**

在`config.h`或`PinDefines.h`中添加配置：
- 参数定义
- 引脚定义（如需要）

**示例：添加新传感器**

**步骤1：定义接口**
```cpp
// sensor.h
namespace hexapod {
    class Sensor {
    public:
        void init();
        float read();
    };
}
```

**步骤2：实现功能**
```cpp
// sensor.cpp
#include "sensor.h"
#include "PinDefines.h"

void Sensor::init() {
    pinMode(SENSOR_PIN, INPUT);
}

float Sensor::read() {
    return analogRead(SENSOR_PIN) * 3.3 / 4095.0;
}
```

**步骤3：添加到主程序**
```cpp
// main.cpp
#include "sensor.h"
hexapod::Sensor sensor;

void setup() {
    // ... 其他初始化 ...
    sensor.init();
}
```

**步骤4：添加引脚定义**
```cpp
// PinDefines.h
#define SENSOR_PIN 35
```

#  11.5 调试技巧

**串口调试：**

**启用调试输出：**

在`main.cpp`中启用调试宏：
```cpp
#define DEBUG_ADC_MONITOR      // 电池电压调试
#define DEBUG_FRAME_RECEIVE    // 帧接收调试
```

**日志输出：**

使用`LOG_INFO`宏输出日志：
```cpp
LOG_INFO("调试信息");
```

**FreeRTOS任务调试：**

查看任务状态：
```cpp
// 打印任务信息
TaskStatus_t taskStatus;
UBaseType_t numTasks = uxTaskGetNumberOfTasks();
vTaskGetInfo(NULL, &taskStatus, pdTRUE, eRunning);
```

**内存调试：**

检查内存使用：
```cpp
Serial.printf("Free heap: %d bytes\n", ESP.getFreeHeap());
Serial.printf("Largest free block: %d bytes\n", ESP.getMaxAllocHeap());
```

**运动学调试：**

使用正运动学验证关节角度：
```cpp
Point3D tipPos;
legs_[0].getTipPositionLocal(tipPos);
Serial.printf("Tip position: (%.2f, %.2f, %.2f)\n", tipPos.x, tipPos.y, tipPos.z);
```

**WebSocket调试：**

在WebSocket事件处理中添加日志：
```cpp
Serial.printf("WebSocket message: %s\n", (char*)data);
```

**常见调试场景：**

1. **运动异常：** 检查轨迹点、逆运动学计算
2. **通信问题：** 检查JSON格式、网络连接
3. **内存不足：** 检查内存使用、优化数据结构
4. **性能问题：** 检查主循环时间、任务优先级

#  11.6 最佳实践

**代码风格：**

1. **命名规范：**
   - 类名：PascalCase（如`HexapodClass`）
   - 函数名：camelCase（如`processMovement`）
   - 常量：UPPER_SNAKE_CASE（如`MOVEMENT_STANDBY`）

2. **注释规范：**
   - 关键函数添加注释说明
   - 复杂算法添加注释
   - TODO标记待完成功能

3. **代码组织：**
   - 相关功能放在同一模块
   - 避免循环依赖
   - 保持接口简洁

**性能优化：**

1. **内存管理：**
   - 使用栈变量而非堆变量（如可能）
   - 避免频繁的内存分配
   - 使用固定大小的数组

2. **计算优化：**
   - 预计算常量值
   - 避免重复计算
   - 使用查找表（如可能）

3. **通信优化：**
   - 减少JSON数据大小
   - 使用二进制协议（如需要）
   - 批量发送数据

**错误处理：**

1. **参数验证：**
   - 检查输入参数范围
   - 验证指针有效性
   - 处理边界情况

2. **异常处理：**
   - 使用返回值表示错误
   - 记录错误日志
   - 优雅降级

3. **资源管理：**
   - 确保资源释放
   - 使用RAII原则
   - 避免资源泄漏

**测试建议：**

1. **单元测试：** 测试关键函数
2. **集成测试：** 测试模块间交互
3. **功能测试：** 测试完整功能
4. **性能测试：** 测试性能指标

**版本控制：**

1. **提交规范：** 使用清晰的提交信息
2. **分支管理：** 使用分支开发新功能
3. **代码审查：** 提交前审查代码

**文档维护：**

1. **更新文档：** 修改代码时同步更新文档
2. **添加注释：** 为复杂代码添加注释
3. **记录变更：** 记录重要变更和决策

---
