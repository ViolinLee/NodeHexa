# 3.1 六足机器人运动学基础

六足机器人的运动控制基于运动学计算。每条腿都有3个自由度（3个关节），通过正运动学和逆运动学实现足端位置与关节角度的相互转换。

## 3.1.1 正运动学

**定义：** 正运动学（Forward Kinematics）是根据已知的关节角度计算足端在空间中的位置。

**腿部结构：**
每条腿由4个连杆组成：
- **根关节到关节1**（`kLegRootToJoint1`）：20.75 mm
- **关节1到关节2**（`kLegJoint1ToJoint2`）：28.0 mm
- **关节2到关节3**（`kLegJoint2ToJoint3`）：42.6 mm
- **关节3到足端**（`kLegJoint3ToTip`）：89.07 mm

**关节角度定义：**
- `angle[0]`：关节1的角度（绕Z轴旋转，控制水平方向）
- `angle[1]`：关节2的角度（控制垂直方向）
- `angle[2]`：关节3的角度（控制足端倾斜）

**正运动学公式：**

```cpp
// 计算中间变量x（在XY平面上的投影长度）
float x = kLegJoint1ToJoint2 + cos(angle[1]) * kLegJoint2ToJoint3 
         + cos(angle[1] + angle[2] - π/2) * kLegJoint3ToTip;

// 计算足端位置（局部坐标系）
out.x = kLegRootToJoint1 + cos(angle[0]) * x;
out.y = sin(angle[0]) * x;
out.z = sin(angle[1]) * kLegJoint2ToJoint3 
      + sin(angle[1] + angle[2] - π/2) * kLegJoint3ToTip;
```

**应用场景：**
- 验证关节角度是否在安全范围内
- 计算足端当前位置
- 调试和可视化

## 3.1.2 逆运动学

**定义：** 逆运动学（Inverse Kinematics）是根据目标足端位置计算所需的关节角度。

**逆运动学计算步骤：**

**步骤1：计算关节1角度（水平旋转）**
```cpp
float x = to.x - kLegRootToJoint1;
float y = to.y;
angle[0] = atan2(y, x);  // 转换为角度
```

**步骤2：计算关节2和关节3角度**

首先计算中间变量：
```cpp
x = sqrt(x*x + y*y) - kLegJoint1ToJoint2;  // 投影到关节2平面
y = to.z;
float ar = atan2(y, x);  // 基准角度
float lr = sqrt(x*x + y*y);  // 关节2到足端的距离
```

然后使用余弦定理求解：
```cpp
// 使用余弦定理计算角度
float a1 = acos((lr² + L2² - L3²) / (2 * L2 * lr));
float a2 = acos((lr² - L2² + L3²) / (2 * L3 * lr));

angle[1] = (ar + a1) * 180 / π;
angle[2] = 90 - ((a1 + a2) * 180 / π);
```

其中：
- `L2 = kLegJoint2ToJoint3`（42.6 mm）
- `L3 = kLegJoint3ToTip`（89.07 mm）

**角度限制：**
- 关节1：-45° ~ 45°
- 关节2：-45° ~ 75°
- 关节3：-60° ~ 60°

**应用场景：**
- 根据目标足端位置控制关节
- 轨迹规划中的实时计算
- 动作执行的核心算法

## 3.1.3 运动学参数定义

**腿部安装位置：**

六条腿的安装位置定义了机器人的几何结构：

| 腿编号 | 安装位置X (mm) | 安装位置Y (mm) | 安装角度 |
|--------|----------------|----------------|----------|
| Leg 0  | 22.41          | 55.41          | 45°      |
| Leg 1  | 29.87          | 0              | 0°       |
| Leg 2  | 22.41          | -55.41         | -45°     |
| Leg 3  | -22.41         | -55.41         | 135°     |
| Leg 4  | -29.87         | 0              | 180°     |
| Leg 5  | -22.41         | 55.41          | 225°     |

**坐标系转换：**

由于每条腿的安装角度不同，需要进行坐标系转换：

1. **世界坐标系 → 局部坐标系：**
   - 先减去安装位置偏移
   - 再根据安装角度旋转

2. **局部坐标系 → 世界坐标系：**
   - 先根据安装角度逆旋转
   - 再加上安装位置偏移

**待机位置计算：**

待机位置基于以下公式计算：
```
STANDBY_Z = kLegJoint3ToTip * cos(15°) - kLegJoint2ToJoint3 * sin(30°)
```

每条腿的基准位置（P1~P6）定义为：
- 保持15°的倾斜角度
- Z轴高度为 `-STANDBY_Z`（负值表示向下）
- 根据安装位置和角度计算X、Y坐标

# 3.2 步态生成原理

## 3.2.1 三足步态（Tripod Gait）

**定义：** 三足步态是六足机器人最常用的步态模式，将6条腿分为两组，每组3条腿交替运动。

**分组方式：**

**组A（支撑组）：** Leg 0, Leg 2, Leg 4
**组B（摆动组）：** Leg 1, Leg 3, Leg 5

**步态周期：**

1. **阶段1（0-50%）：** 组A支撑，组B摆动
   - 组A的腿保持在地面，推动机器人前进
   - 组B的腿抬起并向前摆动

2. **阶段2（50-100%）：** 组B支撑，组A摆动
   - 组B的腿接触地面，继续推动
   - 组A的腿抬起并向前摆动

**优势：**
- 稳定性好：始终有3条腿支撑
- 速度较快：步幅较大
- 能耗适中：交替运动

**实现方式：**

在代码中，通过`entries`数组定义步态的起始点：
```cpp
const int forward_entries[] { 0, 10 };  // 0和10分别是两个步态组的起始索引
```

轨迹表包含20个点，每个步态组占用10个点，形成完整的步态周期。

## 3.2.2 足端轨迹规划

**轨迹形状：** 半圆形轨迹

**轨迹生成算法：**

使用 `semicircle_generator()` 函数生成半圆形轨迹：

```python
def semicircle_generator(radius, steps):
    halfsteps = steps / 2
    
    # 前半段：直线后退（只有Y变化）
    for i in range(halfsteps):
        y = radius - i * radius * 2 / halfsteps
        result.append((0, y, 0))
    
    # 后半段：半圆形前进（Y和Z变化）
    for i in range(halfsteps):
        angle = π - step_angle * i
        y = radius * cos(angle)
        z = radius * sin(angle)
        result.append((0, y, z))
```

**轨迹特点：**

1. **抬腿阶段：** 足端先抬起（Z增加），同时向后移动（Y减少）
2. **摆动阶段：** 足端在半圆形轨迹上向前移动
3. **落地阶段：** 足端回到起始位置，准备下一周期

**参数说明：**

- `radius`：轨迹半径（默认25mm）
- `steps`：轨迹点数量（默认20点）
- `stepDuration`：每步持续时间（默认20ms）

**轨迹优化：**

- 使用 `deque.rotate()` 调整轨迹起点，使步态更平滑
- 通过旋转四分之一周期，使抬腿动作更自然

**不同运动模式的轨迹：**

- **前进/后退：** 标准半圆形轨迹
- **转向：** 在标准轨迹基础上添加旋转分量
- **平移：** 横向移动轨迹
- **旋转：** 使用旋转矩阵变换基准位置

## 3.2.3 动作组概念

**定义：** 动作组（Movement Table）是预定义的足端轨迹序列，包含完整的步态周期。

**动作组结构：**

```cpp
struct MovementTable {
    const Locations* table;     // 轨迹点数组
    int length;                 // 轨迹点数量
    int stepDuration;           // 每步持续时间（毫秒）
    const int* entries;         // 步态入口索引数组
    int entriesCount;           // 入口数量
};
```

**动作组特点：**

1. **预计算：** 所有轨迹点预先计算并存储
2. **循环播放：** 轨迹表循环播放，形成连续运动
3. **多入口：** 支持多个步态组，实现交替步态

**动作组生成流程：**

1. **Python脚本生成：** 使用 `pathTool` 工具生成轨迹点
2. **验证：** 使用逆运动学验证每个点的可行性
3. **代码生成：** 生成C++格式的动作表头文件
4. **编译集成：** 编译到固件中

**优势：**

- **实时性好：** 无需实时计算，直接查表
- **精度高：** 预计算保证轨迹准确性
- **资源占用少：** 仅存储关键轨迹点
- **易于扩展：** 通过修改Python脚本即可添加新动作

**动作组示例：**

前进动作组包含20个轨迹点：
- 点0-9：第一个步态组（组A支撑，组B摆动）
- 点10-19：第二个步态组（组B支撑，组A摆动）
- 循环播放形成连续前进运动

# 3.3 控制系统原理

## 3.3.1 基于动作组的控制架构

**控制流程：**

```
用户指令 → 运动模式选择 → 动作组查找 → 轨迹点索引 → 插值计算 → 逆运动学 → 舵机控制
```

**核心组件：**

1. **HexapodClass：** 顶层控制类
   - 管理6条腿的实例
   - 处理运动模式切换
   - 协调各腿的运动

2. **Movement：** 动作执行器
   - 管理当前动作组
   - 计算下一帧的足端位置
   - 处理模式切换的插值过渡

3. **Leg：** 腿部控制器
   - 执行逆运动学计算
   - 控制3个关节的舵机
   - 管理坐标系转换

**控制循环：**

主循环每20ms执行一次：
```cpp
void normal_loop() {
    auto t0 = millis();
    
    // 1. 获取当前运动模式
    MovementMode mode = getCurrentMode();
    
    // 2. 处理运动，获取下一帧位置
    hexapod::Hexapod.processMovement(mode, REACT_DELAY);
    
    // 3. 控制时间间隔
    auto spent = millis() - t0;
    if(spent < REACT_DELAY) {
        delay(REACT_DELAY - spent);
    }
}
```

**数据流：**

1. `processMovement()` 调用 `movement_.next()` 获取下一帧的 `Locations`
2. 遍历6条腿，调用 `legs_[i].moveTip()` 设置足端位置
3. `moveTip()` 内部执行逆运动学，计算关节角度
4. 调用 `servo->setAngle()` 设置舵机角度
5. PCA9685驱动板输出PWM信号控制舵机

## 3.3.2 运动模式切换机制

**切换流程：**

当接收到新的运动模式指令时：

1. **模式检测：**
```cpp
if (mode_ != mode) {
    mode_ = mode;
    movement_.setMode(mode_);
}
```

2. **动作组切换：**
```cpp
void Movement::setMode(MovementMode newMode) {
    mode_ = newMode;
    const MovementTable& table = kTable[mode_];
    
    // 随机选择步态入口点
    index_ = table.entries[rand() % table.entriesCount];
    
    // 计算过渡时间
    remainTime_ = max(switchDuration, stepDuration);
}
```

3. **平滑过渡：**

使用插值算法实现平滑过渡：
```cpp
const Locations& Movement::next(int elapsed) {
    // 计算插值比例
    float ratio = (float)elapsed / remainTime_;
    
    // 线性插值
    position_ += (table.table[index_] - position_) * ratio;
    
    return position_;
}
```

**过渡时间：**

- 默认过渡时间：150ms（`movementSwitchDuration`）
- 根据速度调整：`actualSwitchDuration = switchDuration / speed`
- 确保过渡时间不小于步进时间

**优势：**

- **平滑切换：** 避免突然的位置跳变
- **稳定性好：** 插值过渡保证机器人稳定
- **响应快：** 150ms的过渡时间兼顾速度和稳定性

## 3.3.3 速度控制策略

**速度定义：**

速度通过倍数（multiplier）控制，范围：0.25 ~ 1.0
- `1.0`：最快速度（原始速度）
- `0.5`：中等速度（默认值）
- `0.25`：最慢速度

**速度等级：**

系统提供4个速度等级：

| 等级 | 倍数 | 说明 |
|------|------|------|
| SPEED_SLOWEST | 0.25 | 极慢 |
| SPEED_SLOW | 0.33 | 慢速 |
| SPEED_MEDIUM | 0.5 | 中速（默认） |
| SPEED_FAST | 1.0 | 快速 |

**速度控制实现：**

```cpp
void Movement::setSpeed(float speed) {
    // 限制速度范围
    if (speed < minSpeed) speed = minSpeed;
    else if (speed > maxSpeed) speed = maxSpeed;
    
    speed_ = speed;
}

const Locations& Movement::next(int elapsed) {
    // 根据速度调整步进时间
    int actualStepDuration = (int)(table.stepDuration / speed_);
    
    // 调整索引步进速度
    if (remainTime_ <= 0) {
        index_ = (index_ + 1) % table.length;
        remainTime_ = actualStepDuration;
    }
    
    // ... 插值计算
}
```

**速度控制原理：**

1. **时间缩放：** 通过调整 `stepDuration` 实现速度控制
   - 速度越快，`actualStepDuration` 越小
   - 速度越慢，`actualStepDuration` 越大

2. **轨迹点索引：** 索引步进速度随速度倍数变化
   - 1.0倍速：正常步进
   - 0.5倍速：每帧步进更慢
   - 0.25倍速：每帧步进最慢

**速度限制：**

- **最小速度：** 0.25（受舵机响应速度限制）
- **最大速度：** 1.0（受舵机最大运动速度限制）
- **实际限制：** 舵机频率为50Hz（20ms周期），速度控制必须是离散的

**应用场景：**

- **精细操作：** 使用慢速模式（0.25-0.33）
- **正常移动：** 使用中速模式（0.5）
- **快速移动：** 使用快速模式（1.0）

# 3.4 通信原理

## 3.4.1 WiFi AP模式

**工作原理：**

NodeHexa启动后自动创建WiFi热点（Access Point），无需外部路由器。

**配置参数：**

```cpp
const char* ssid = "NodeHexa";           // WiFi名称
const char* password = "roboticscv666";  // WiFi密码
```

**初始化流程：**

```cpp
// 1. 初始化WiFi
WiFi.softAP(ssid, password);

// 2. 获取IP地址
IPAddress apIP = WiFi.softAPIP();
// 默认IP: 192.168.4.1

// 3. 启动Web服务器
server.begin();
```

**网络拓扑：**

```
手机/电脑 ←→ WiFi热点 (NodeHexa) ←→ ESP32
          (192.168.4.1)
```

**特点：**

- **即插即用：** 无需配置路由器
- **独立运行：** 可在任何环境下使用
- **范围限制：** WiFi覆盖范围约10-30米
- **连接数限制：** 最多支持4个客户端同时连接

## 3.4.2 WebSocket实时控制

**WebSocket优势：**

- **双向通信：** 客户端和服务器可随时发送数据
- **低延迟：** 无需HTTP请求/响应开销
- **实时性：** 适合实时控制场景

**连接建立：**

```cpp
// 服务器端
AsyncWebSocket wsRoverCmd("/cmd");
server.addHandler(&wsRoverCmd);

// 客户端（JavaScript）
const ws = new WebSocket('ws://192.168.4.1/cmd');
```

**消息格式：**

**控制指令（JSON格式）：**
```json
{
    "movementMode": 1,      // 运动模式编号（1=前进）
    "speed": 0.5,          // 速度倍数（可选）
    "speedLevel": 2        // 速度等级（可选）
}
```

**运动模式编号：**
- `0`：待机
- `1`：前进
- `2`：快速前进
- `3`：后退
- `4`：左转
- `5`：右转
- `6`：左移
- `7`：右移
- `8`：攀爬
- `9`：X轴旋转
- `10`：Y轴旋转
- `11`：Z轴旋转
- `12`：扭转

**消息处理：**

```cpp
void onRobotCmdWebSocketEvent(AsyncWebSocket *server, 
                              AsyncWebSocketClient *client, 
                              AwsEventType type,
                              void *arg, 
                              uint8_t *data, 
                              size_t len) {
    if (type == WS_EVT_DATA) {
        // 解析JSON
        StaticJsonDocument<128> json;
        deserializeJson(json, data);
        
        // 获取运动模式
        if (json.containsKey("movementMode")) {
            int16_t movementMode = json["movementMode"];
            // 使用互斥锁保护flag
            xSemaphoreTake(flagMutex, portMAX_DELAY);
            flag = movementMode;
            xSemaphoreGive(flagMutex);
        }
        
        // 速度控制
        if (json.containsKey("speed")) {
            float speed = json["speed"];
            hexapod::Hexapod.setMovementSpeed(speed);
        }
    }
}
```

**线程安全：**

使用FreeRTOS互斥锁保护共享变量：
```cpp
SemaphoreHandle_t flagMutex;  // 互斥锁

// 获取锁
xSemaphoreTake(flagMutex, pdMS_TO_TICKS(10));

// 修改共享变量
flag = movementMode;

// 释放锁
xSemaphoreGive(flagMutex);
```

## 3.4.3 串口通信协议

**硬件配置：**

- **串口：** UART2
- **波特率：** 115200
- **引脚：** GPIO16（RX）、GPIO17（TX）

**数据帧格式：**

```
$<JSON数据>\n
```

- `$`：帧起始符
- `<JSON数据>`：JSON格式的控制指令
- `\n`：帧结束符

**指令格式：**

与WebSocket格式相同：
```json
${"movementMode": 1, "speed": 0.5}\n
```

**接收处理：**

```cpp
void SerialCommandTask(void *pvParameters) {
    while(1) {
        while (Serial2.available()) {
            char c = Serial2.read();
            
            // 帧接收状态机
            if (!frameStarted) {
                if (c == '$') {
                    frameStarted = true;
                    serialBuffer = "";
                }
            } else {
                if (c == '\n' || c == '\r') {
                    // 帧接收完成，解析指令
                    parseSerialMovementCommand(serialBuffer);
                    frameStarted = false;
                    serialBuffer = "";
                } else {
                    serialBuffer += c;
                }
            }
        }
        
        vTaskDelay(pdMS_TO_TICKS(10));  // 10ms延时
    }
}
```

**响应格式：**

服务器发送响应：
```
${"status":"success","movementMode":1,"message":"Movement command executed"}\n
```

**超时处理：**

- 超时时间：1000ms
- 超时后清空缓冲区，防止数据堆积

**应用场景：**

- **外部控制器：** 通过串口连接其他MCU
- **调试：** 通过串口发送测试指令
- **自动化：** 集成到自动化系统中

**优势：**

- **可靠性高：** 串口通信稳定可靠
- **延迟低：** 直接硬件通信，无网络延迟
- **兼容性好：** 标准UART协议，易于集成

---
