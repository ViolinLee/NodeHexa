本章节详细介绍NodeHexa六足机器人的通信协议，包括WebSocket协议、串口通信协议和HTTP接口的详细规范。这些协议允许外部程序或设备控制机器人。

#  9.1 WebSocket协议

##  9.1.1 连接方式

**WebSocket端点：**

- **URL：** `ws://192.168.4.1/cmd`
- **协议：** WebSocket (WS)
- **端口：** 80（HTTP端口）

**连接建立：**

**JavaScript示例：**
```javascript
const ws = new WebSocket('ws://192.168.4.1/cmd');

ws.onopen = function(event) {
    console.log('WebSocket连接已建立');
};

ws.onclose = function(event) {
    console.log('WebSocket连接已关闭');
    // 自动重连逻辑
    setTimeout(() => {
        ws = new WebSocket('ws://192.168.4.1/cmd');
    }, 2000);
};

ws.onerror = function(error) {
    console.error('WebSocket错误:', error);
};
```

**Python示例：**
```python
import websocket

def on_message(ws, message):
    print(f"收到消息: {message}")

def on_error(ws, error):
    print(f"错误: {error}")

def on_close(ws):
    print("连接已关闭")

def on_open(ws):
    print("连接已打开")
    # 发送测试消息
    ws.send('{"movementMode": 0}')

ws = websocket.WebSocketApp("ws://192.168.4.1/cmd",
                          on_message=on_message,
                          on_error=on_error,
                          on_close=on_close,
                          on_open=on_open)
ws.run_forever()
```

**连接状态：**

- **OPEN：** 连接已建立，可以发送和接收消息
- **CLOSED：** 连接已关闭
- **CONNECTING：** 正在连接
- **CLOSING：** 正在关闭连接

**连接管理：**

- 服务器支持多个客户端同时连接（最多4个）
- 客户端断开连接时，机器人会自动停止运动（flag设为0）
- 建议实现自动重连机制，确保连接稳定

##  9.1.2 消息格式

**消息类型：**

所有消息采用JSON格式，文本模式（WS_TEXT）。

**消息大小限制：**

- 最大消息大小：128字节（受`StaticJsonDocument<128>`限制）
- 建议消息大小：不超过100字节

**消息编码：**

- 编码：UTF-8
- 格式：JSON文本字符串

**消息结构：**

所有消息都是JSON对象，包含以下可选字段：

```json
{
  "movementMode": 0,      // 运动模式（可选）
  "speed": 0.5,          // 速度倍数（可选）
  "speedLevel": 2        // 速度等级（可选）
}
```

**字段说明：**

- **movementMode：** 整数，运动模式编号（0-12）
- **speed：** 浮点数，速度倍数（0.25-1.0）
- **speedLevel：** 整数，速度等级（0-3）

**字段组合：**

可以同时发送多个字段：
```json
{
  "movementMode": 1,
  "speed": 0.5
}
```

**消息验证：**

- JSON格式必须正确，否则会返回错误
- 字段值必须在有效范围内
- 无效字段会被忽略

##  9.1.3 运动模式指令

**指令格式：**

```json
{
  "movementMode": <模式编号>
}
```

**模式编号表：**

| 编号 | 枚举值 | 说明 |
|------|--------|------|
| 0 | MOVEMENT_STANDBY | 待机 |
| 1 | MOVEMENT_FORWARD | 前进 |
| 2 | MOVEMENT_FORWARDFAST | 快速前进 |
| 3 | MOVEMENT_BACKWARD | 后退 |
| 4 | MOVEMENT_TURNLEFT | 左转 |
| 5 | MOVEMENT_TURNRIGHT | 右转 |
| 6 | MOVEMENT_SHIFTLEFT | 左移 |
| 7 | MOVEMENT_SHIFTRIGHT | 右移 |
| 8 | MOVEMENT_CLIMB | 攀爬 |
| 9 | MOVEMENT_ROTATEX | X轴旋转 |
| 10 | MOVEMENT_ROTATEY | Y轴旋转 |
| 11 | MOVEMENT_ROTATEZ | Z轴旋转 |
| 12 | MOVEMENT_TWIST | 扭转 |

**使用示例：**

**前进：**
```json
{"movementMode": 1}
```

**左转：**
```json
{"movementMode": 4}
```

**待机（停止）：**
```json
{"movementMode": 0}
```

**模式切换：**

- 发送新的运动模式指令会立即切换模式
- 系统会自动进行平滑过渡（约150ms）
- 切换过程中不会中断运动

**响应：**

WebSocket协议不返回响应消息，客户端通过观察机器人运动状态确认指令是否生效。

**错误处理：**

- 无效的模式编号会被忽略
- JSON解析错误会在串口输出错误信息
- 网络错误需要客户端自行处理

##  9.1.4 速度控制指令

**速度倍数控制：**

**指令格式：**
```json
{
  "speed": <速度倍数>
}
```

**速度范围：**
- 最小值：0.25
- 最大值：1.0
- 默认值：0.5

**使用示例：**
```json
{"speed": 0.5}   // 中等速度
{"speed": 1.0}   // 最快速度
{"speed": 0.25}  // 最慢速度
```

**速度等级控制：**

**指令格式：**
```json
{
  "speedLevel": <等级编号>
}
```

**等级编号：**

| 等级 | 数值 | 倍数 | 说明 |
|------|------|------|------|
| SPEED_SLOWEST | 0 | 0.25 | 极慢 |
| SPEED_SLOW | 1 | 0.33 | 慢速 |
| SPEED_MEDIUM | 2 | 0.5 | 中速（默认） |
| SPEED_FAST | 3 | 1.0 | 快速 |

**使用示例：**
```json
{"speedLevel": 2}  // 中速
{"speedLevel": 3}  // 快速
```

**速度控制特性：**

- 速度设置立即生效
- 速度变化会平滑过渡
- 速度倍数和速度等级可以同时使用（速度等级会覆盖速度倍数）
- 速度设置会持续生效，直到下次修改

**组合使用：**

可以同时设置运动模式和速度：
```json
{
  "movementMode": 1,
  "speed": 0.5
}
```

#  9.2 串口通信协议

##  9.2.1 数据帧格式

**帧结构：**

串口通信采用帧格式，确保数据完整性：

```
$<JSON数据>\n
```

**帧组成部分：**

1. **起始符：** `$`（美元符号，0x24）
2. **数据部分：** JSON格式的指令数据
3. **结束符：** `\n`（换行符，0x0A）

**帧示例：**

```
${"movementMode":1}\n
```

**帧接收状态机：**

服务器使用状态机接收帧：

1. **等待起始符：** 等待`$`字符
2. **接收数据：** 接收JSON数据，直到遇到`\n`
3. **处理帧：** 解析JSON并执行指令
4. **重置状态：** 准备接收下一帧

**超时处理：**

- 超时时间：1000ms
- 如果超过超时时间未收到完整帧，会清空缓冲区
- 防止数据堆积和缓冲区溢出

**帧大小限制：**

- 最大帧大小：受串口缓冲区限制（通常512字节）
- 建议帧大小：不超过200字节

##  9.2.2 指令类型

**运动模式指令：**

```json
{
  "movementMode": <模式编号>
}
```

**速度控制指令：**

```json
{
  "speed": <速度倍数>
}
```

或

```json
{
  "speedLevel": <等级编号>
}
```

**组合指令：**

```json
{
  "movementMode": 1,
  "speed": 0.5,
  "speedLevel": 2
}
```

**指令格式：**

与WebSocket协议相同，采用JSON格式。

**指令字段：**

- **movementMode：** 整数，运动模式编号（0-12）
- **speed：** 浮点数，速度倍数（0.25-1.0）
- **speedLevel：** 整数，速度等级（0-3）

**指令验证：**

- JSON格式必须正确
- 字段值必须在有效范围内
- 无效指令会返回错误响应

##  9.2.3 响应格式

**响应帧格式：**

响应也采用帧格式：
```
$<JSON响应>\n
```

**成功响应：**

**运动模式响应：**
```json
{
  "status": "success",
  "movementMode": 1,
  "message": "Movement command executed"
}
```

**速度设置响应：**
```json
{
  "status": "success",
  "speed": 0.5,
  "message": "Speed updated"
}
```

**速度等级响应：**
```json
{
  "status": "success",
  "speedLevel": 2,
  "speed": 0.5,
  "message": "Speed level updated"
}
```

**重复指令响应：**
```json
{
  "status": "success",
  "movementMode": 1,
  "message": "Movement mode already set"
}
```

**错误响应：**

**JSON格式错误：**
```json
{
  "status": "error",
  "message": "Invalid JSON format"
}
```

**无效指令：**
```json
{
  "status": "error",
  "message": "Invalid movement mode"
}
```

**系统忙：**
```json
{
  "status": "error",
  "message": "System busy, command ignored"
}
```

**无有效字段：**
```json
{
  "status": "error",
  "message": "No valid command field found"
}
```

**响应处理：**

客户端应该：
1. 接收响应帧（以`$`开头，`\n`结尾）
2. 解析JSON响应
3. 检查`status`字段
4. 根据状态进行相应处理

**响应超时：**

- 响应通常在100ms内返回
- 如果超过1秒未收到响应，可能是连接问题
- 建议实现超时处理机制

#  9.3 HTTP接口

##  9.3.1 页面路由

**页面路由表：**

| 路径 | 方法 | 说明 | 响应类型 |
|------|------|------|----------|
| `/` | GET | 主控制页面 | HTML (gzip) |
| `/calibration` | GET | 校准页面 | HTML (gzip) |
| `/calibration` | POST | 校准数据提交 | JSON |
| 其他 | - | 404错误 | 文本 |

**主控制页面：**

**请求：**
```
GET / HTTP/1.1
Host: 192.168.4.1
```

**响应：**
- Content-Type: `text/html; charset=utf-8`
- Content-Encoding: `gzip`
- 压缩的HTML页面

**校准页面：**

**请求：**
```
GET /calibration HTTP/1.1
Host: 192.168.4.1
```

**响应：**
- Content-Type: `text/html; charset=utf-8`
- Content-Encoding: `gzip`
- 压缩的HTML页面

**404错误：**

**请求：**
```
GET /invalid HTTP/1.1
Host: 192.168.4.1
```

**响应：**
```
HTTP/1.1 404 Not Found
Content-Type: text/plain

File Not Found
```

##  9.3.2 校准接口

**校准数据提交：**

**端点：** `/calibration`  
**方法：** POST  
**Content-Type：** `application/json`

**请求格式：**

**设置校准偏移：**
```json
{
  "legIndex": 0,
  "partIndex": 0,
  "offset": 10,
  "modeChanged": false
}
```

**进入校准模式：**
```json
{
  "modeChanged": true,
  "operation": "CALIBRATESTART"
}
```

**保存并退出校准模式：**
```json
{
  "modeChanged": true,
  "operation": "CALIBRATESAVE"
}
```

**字段说明：**

- **legIndex：** 整数，腿编号（0-5）
- **partIndex：** 整数，关节编号（0-2）
- **offset：** 整数，偏移量（PWM脉宽微秒）
- **modeChanged：** 布尔值，是否切换模式
- **operation：** 字符串，操作类型（"CALIBRATESTART"或"CALIBRATESAVE"）

**响应格式：**

**成功响应：**
```json
{
  "status": "success"
}
```

**保存后响应：**

保存校准数据后，会返回主控制页面（HTML）。

**错误处理：**

- JSON格式错误：返回400错误
- 无效字段：返回400错误
- 模式错误：返回错误响应

**使用示例：**

**JavaScript示例：**
```javascript
// 设置校准偏移
function setCalibration(legIndex, partIndex, offset) {
    fetch('/calibration', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            legIndex: legIndex,
            partIndex: partIndex,
            offset: offset,
            modeChanged: false
        })
    })
    .then(response => response.json())
    .then(data => console.log('Success:', data));
}

// 进入校准模式
function startCalibration() {
    fetch('/calibration', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            modeChanged: true,
            operation: 'CALIBRATESTART'
        })
    })
    .then(response => response.json())
    .then(data => console.log('Success:', data));
}

// 保存并退出
function saveCalibration() {
    fetch('/calibration', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            modeChanged: true,
            operation: 'CALIBRATESAVE'
        })
    })
    .then(response => response.text())
    .then(html => {
        // 页面会跳转到主控制页面
        document.body.innerHTML = html;
    });
}
```

**Python示例：**
```python
import requests

# 设置校准偏移
def set_calibration(leg_index, part_index, offset):
    url = 'http://192.168.4.1/calibration'
    data = {
        'legIndex': leg_index,
        'partIndex': part_index,
        'offset': offset,
        'modeChanged': False
    }
    response = requests.post(url, json=data)
    return response.json()

# 进入校准模式
def start_calibration():
    url = 'http://192.168.4.1/calibration'
    data = {
        'modeChanged': True,
        'operation': 'CALIBRATESTART'
    }
    response = requests.post(url, json=data)
    return response.json()

# 保存并退出
def save_calibration():
    url = 'http://192.168.4.1/calibration'
    data = {
        'modeChanged': True,
        'operation': 'CALIBRATESAVE'
    }
    response = requests.post(url, json=data)
    return response.text  # 返回HTML页面
```

**注意事项：**

- 校准数据会立即生效
- 进入校准模式会清除所有现有偏移
- 保存校准数据会写入Flash存储
- 保存后会自动退出校准模式

---
